/* gexiv2-dump.c generated by valac 0.36.6, the Vala compiler
 * generated from gexiv2-dump.vala, do not modify */

/*
 * gexiv2-dump.vala
 *
 * Author(s)
 *  Jim Nelson <jim@yorba.org>
 *
 * This is free software. See COPYING for details.
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gexiv2/gexiv2.h>
#include <stdio.h>

#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))



gint _vala_main (gchar** args, int args_length1);
static gboolean _vala_string_array_contains (gchar* * stack, int stack_length, gchar* needle);
void usage (void);
void dump_tags (GExiv2Metadata* metadata, gchar** tags, int tags_length1, GError** error);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


static gboolean _vala_string_array_contains (gchar* * stack, int stack_length, gchar* needle) {
	int i;
	for (i = 0; i < stack_length; i++) {
		if (g_strcmp0 (stack[i], needle) == 0) {
			return TRUE;
		}
	}
	return FALSE;
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gchar** _tmp5_;
	gint _tmp5__length1;
	gchar** _tmp6_;
	gint _tmp6__length1;
	GError * _inner_error_ = NULL;
	_tmp2_ = args;
	_tmp2__length1 = args_length1;
	if (_tmp2__length1 < 2) {
		_tmp1_ = TRUE;
	} else {
		gchar** _tmp3_;
		gint _tmp3__length1;
		_tmp3_ = args;
		_tmp3__length1 = args_length1;
		_tmp1_ = _vala_string_array_contains (_tmp3_, _tmp3__length1, "--help");
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gchar** _tmp4_;
		gint _tmp4__length1;
		_tmp4_ = args;
		_tmp4__length1 = args_length1;
		_tmp0_ = _vala_string_array_contains (_tmp4_, _tmp4__length1, "-h");
	}
	if (_tmp0_) {
		usage ();
		result = 1;
		return result;
	}
	_tmp5_ = args;
	_tmp5__length1 = args_length1;
	_tmp6_ = args;
	_tmp6__length1 = args_length1;
	{
		gchar** filename_collection = NULL;
		gint filename_collection_length1 = 0;
		gint _filename_collection_size_ = 0;
		gint filename_it = 0;
		filename_collection = _tmp5_ + 1;
		filename_collection_length1 = _tmp6__length1 - 1;
		for (filename_it = 0; filename_it < (_tmp6__length1 - 1); filename_it = filename_it + 1) {
			gchar* _tmp7_;
			gchar* filename = NULL;
			_tmp7_ = g_strdup (filename_collection[filename_it]);
			filename = _tmp7_;
			{
				{
					GExiv2Metadata* metadata = NULL;
					GExiv2Metadata* _tmp8_;
					GExiv2Metadata* _tmp9_;
					const gchar* _tmp10_;
					GExiv2Metadata* _tmp11_;
					GExiv2Metadata* _tmp12_;
					gchar** _tmp13_;
					gchar** _tmp14_;
					gchar** _tmp15_;
					gint _tmp15__length1;
					GExiv2Metadata* _tmp16_;
					GExiv2Metadata* _tmp17_;
					gchar** _tmp18_;
					gchar** _tmp19_;
					gchar** _tmp20_;
					gint _tmp20__length1;
					GExiv2Metadata* _tmp21_;
					GExiv2Metadata* _tmp22_;
					gchar** _tmp23_;
					gchar** _tmp24_;
					gchar** _tmp25_;
					gint _tmp25__length1;
					_tmp8_ = gexiv2_metadata_new ();
					metadata = _tmp8_;
					_tmp9_ = metadata;
					_tmp10_ = filename;
					gexiv2_metadata_open_path (_tmp9_, _tmp10_, &_inner_error_);
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						_g_object_unref0 (metadata);
						goto __catch0_g_error;
					}
					_tmp11_ = metadata;
					_tmp12_ = metadata;
					_tmp14_ = _tmp13_ = gexiv2_metadata_get_exif_tags (_tmp12_);
					_tmp15_ = _tmp14_;
					_tmp15__length1 = _vala_array_length (_tmp13_);
					dump_tags (_tmp11_, _tmp15_, _vala_array_length (_tmp13_), &_inner_error_);
					_tmp15_ = (_vala_array_free (_tmp15_, _tmp15__length1, (GDestroyNotify) g_free), NULL);
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						_g_object_unref0 (metadata);
						goto __catch0_g_error;
					}
					_tmp16_ = metadata;
					_tmp17_ = metadata;
					_tmp19_ = _tmp18_ = gexiv2_metadata_get_iptc_tags (_tmp17_);
					_tmp20_ = _tmp19_;
					_tmp20__length1 = _vala_array_length (_tmp18_);
					dump_tags (_tmp16_, _tmp20_, _vala_array_length (_tmp18_), &_inner_error_);
					_tmp20_ = (_vala_array_free (_tmp20_, _tmp20__length1, (GDestroyNotify) g_free), NULL);
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						_g_object_unref0 (metadata);
						goto __catch0_g_error;
					}
					_tmp21_ = metadata;
					_tmp22_ = metadata;
					_tmp24_ = _tmp23_ = gexiv2_metadata_get_xmp_tags (_tmp22_);
					_tmp25_ = _tmp24_;
					_tmp25__length1 = _vala_array_length (_tmp23_);
					dump_tags (_tmp21_, _tmp25_, _vala_array_length (_tmp23_), &_inner_error_);
					_tmp25_ = (_vala_array_free (_tmp25_, _tmp25__length1, (GDestroyNotify) g_free), NULL);
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						_g_object_unref0 (metadata);
						goto __catch0_g_error;
					}
					_g_object_unref0 (metadata);
				}
				goto __finally0;
				__catch0_g_error:
				{
					GError* err = NULL;
					FILE* _tmp26_;
					const gchar* _tmp27_;
					GError* _tmp28_;
					const gchar* _tmp29_;
					err = _inner_error_;
					_inner_error_ = NULL;
					_tmp26_ = stderr;
					_tmp27_ = filename;
					_tmp28_ = err;
					_tmp29_ = _tmp28_->message;
					fprintf (_tmp26_, "Unable to dump metadata for %s: %s\n", _tmp27_, _tmp29_);
					_g_error_free0 (err);
				}
				__finally0:
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					gint _tmp30_ = 0;
					_g_free0 (filename);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return _tmp30_;
				}
				_g_free0 (filename);
			}
		}
	}
	result = 0;
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return _vala_main (argv, argc);
}


void usage (void) {
	FILE* _tmp0_;
	_tmp0_ = stdout;
	fprintf (_tmp0_, "usage: gexiv2-dump FILE...\n\n");
}


void dump_tags (GExiv2Metadata* metadata, gchar** tags, int tags_length1, GError** error) {
	gchar** _tmp0_;
	gint _tmp0__length1;
	g_return_if_fail (metadata != NULL);
	_tmp0_ = tags;
	_tmp0__length1 = tags_length1;
	{
		gchar** tag_collection = NULL;
		gint tag_collection_length1 = 0;
		gint _tag_collection_size_ = 0;
		gint tag_it = 0;
		tag_collection = _tmp0_;
		tag_collection_length1 = _tmp0__length1;
		for (tag_it = 0; tag_it < _tmp0__length1; tag_it = tag_it + 1) {
			gchar* _tmp1_;
			gchar* tag = NULL;
			_tmp1_ = g_strdup (tag_collection[tag_it]);
			tag = _tmp1_;
			{
				FILE* _tmp2_;
				const gchar* _tmp3_;
				const gchar* _tmp4_;
				gint _tmp5_;
				gint _tmp6_;
				gint _tmp7_;
				GExiv2Metadata* _tmp8_;
				const gchar* _tmp9_;
				gchar* _tmp10_;
				gchar* _tmp11_;
				_tmp2_ = stdout;
				_tmp3_ = tag;
				_tmp4_ = tag;
				_tmp5_ = strlen (_tmp4_);
				_tmp6_ = _tmp5_;
				_tmp7_ = CLAMP (64 - _tmp6_, 1, 64);
				_tmp8_ = metadata;
				_tmp9_ = tag;
				_tmp10_ = gexiv2_metadata_get_tag_interpreted_string (_tmp8_, _tmp9_);
				_tmp11_ = _tmp10_;
				fprintf (_tmp2_, "%s%*s%s\n", _tmp3_, _tmp7_, "", _tmp11_);
				_g_free0 (_tmp11_);
				_g_free0 (tag);
			}
		}
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



